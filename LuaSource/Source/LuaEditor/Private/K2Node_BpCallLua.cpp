// Fill out your copyright notice in the Description page of Project Settings.

#include "K2Node_BpCallLua.h"
#include "EdGraphSchema_K2.h"
#include "BlueprintNodeSpawner.h"
#include "BlueprintActionDatabaseRegistrar.h"
#include "K2Node_MakeArray.h"
#include "K2Node_MakeStruct.h"
#include "K2Node_Self.h"
#include "KismetCompiler.h"
#include "K2Node_CallFunction.h"
#include "BlueprintEditorUtils.h"
#include "MultiBox/MultiBoxBuilder.h"
#include "ToolMenu.h"
#include "ScopedTransaction.h"
#include "LuaBlueprintLibrary.h"
#include "LuaBlueprintBridge.h"

#define LOCTEXT_NAMESPACE "K2Node_Lua"

struct FGetPinName
{
	static const FName& GetObjPin()
	{
		static const FName ObjPinName(TEXT("Ins"));
		return ObjPinName;
	}

	static const FName& GetFuncPin()
	{
		static const FName FuncPinName(TEXT("Func"));
		return FuncPinName;
	}

	static FString GetVariableInputPin(const int32 InIndex)
	{
		FString VariableName = FString::Printf(TEXT("LuaInput%d"), InIndex);
		return VariableName;
	}

	static FString GetVariableOutputPin(const int32 InIndex)
	{
		FString VariableName = FString::Printf(TEXT("LuaOutput%d"), InIndex);
		return VariableName;
	}

	static const FName & GetStateNamePin()
	{
		static const FName StateNamePinName(TEXT("StateName"));
		return StateNamePinName;
	}
};

UK2Node_BpCallLua::UK2Node_BpCallLua(const FObjectInitializer& ObjectInitializer)
	: Super(ObjectInitializer)
{
	InputPinNums = 0;
	OutputPinNums = 0;
}

void UK2Node_BpCallLua::AllocateDefaultPins()
{
	Super::AllocateDefaultPins();

	const UEdGraphSchema_K2* K2Schema = GetDefault<UEdGraphSchema_K2>();

	/*Create our pins*/

	// Execution pins
	CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Exec, UEdGraphSchema_K2::PN_Execute);
	CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Exec, UEdGraphSchema_K2::PN_Then);

	
	//Input

	UEdGraphPin* InObjPin = CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Object, UObject::StaticClass(),
	                                  FGetPinName::GetObjPin());

	K2Schema->SetPinAutogeneratedDefaultValue(InObjPin, FString("Ins"));

	UEdGraphPin* InFuncNameTextPin = CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_String, FGetPinName::GetFuncPin());
	K2Schema->SetPinAutogeneratedDefaultValue(InFuncNameTextPin, FString("FunctionName"));

	CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_String, FGetPinName::GetStateNamePin());
	K2Schema->SetPinAutogeneratedDefaultValue(InObjPin, FString(""));

	for (int32 i = 0; i < InputPinNums; ++i)
	{
		AddInputPinsInner(i);
	}

	
}

FText UK2Node_BpCallLua::GetNodeTitle(ENodeTitleType::Type TitleType) const
{
	return LOCTEXT("LuaK2Node_Title", "BPCallLua");
}

FText UK2Node_BpCallLua::GetTooltipText() const
{
	return LOCTEXT("LuaK2Node_Title", "BPCallLua");
}

void UK2Node_BpCallLua::GetNodeContextMenuActions(class UToolMenu* Menu,
												  class UGraphNodeContextMenuContext* Context) const
{
	Super::GetNodeContextMenuActions(Menu, Context);
	if (!Context->bIsDebugging)
	{
		static FName CommutativeAssociativeBinaryOperatorNodeName = FName("BpLuaCallNode");
		FText CommutativeAssociativeBinaryOperatorStr = LOCTEXT("BpLuaCallNode", "Operator");

		if (Context->Pin != NULL)
		{
			if(CanRemovePin(Context->Pin))
			{
				FToolMenuSection& Section = Menu->AddSection(CommutativeAssociativeBinaryOperatorNodeName, CommutativeAssociativeBinaryOperatorStr);
				Section.AddMenuEntry(
					"RemovePin",
					LOCTEXT("RemovePin", "Remove pin"),
					LOCTEXT("RemovePinTooltip", "Remove this input pin"),
					FSlateIcon(),
					FUIAction(
						FExecuteAction::CreateUObject(const_cast<UK2Node_BpCallLua*>(this), 
							&UK2Node_BpCallLua::RemoveInputPin, 
							const_cast<UEdGraphPin*>(Context->Pin)
						)
					)
				);
			}
		}
	}
}

bool UK2Node_BpCallLua::CanRemovePin(const UEdGraphPin * Pin) const
{
	int32 PinIndex = Pins.IndexOfByKey(Pin);
	return (Pin &&  PinIndex != INDEX_NONE && PinIndex == InputPinNums + 4 && InputPinNums >= 1 );
}

void UK2Node_BpCallLua::RemoveInputPin(UEdGraphPin* Pin) 
{
	if (CanRemovePin(Pin))
	{
		FScopedTransaction Transaction(LOCTEXT("RemovePinTx", "RemovePin"));
		Modify();

		if (RemovePin(Pin))
		{
			--InputPinNums;

			
			FBlueprintEditorUtils::MarkBlueprintAsStructurallyModified(GetBlueprint());
		}
	}
}

FText UK2Node_BpCallLua::GetMenuCategory() const
{
	return LOCTEXT("LuaK2Node_Title", "Lua");
}

void UK2Node_BpCallLua::PostReconstructNode()
{
	for (int32 i = 0; i < InputPinNums; ++i)
	{
		UEdGraphPin* InputPin = GetInputPin(i);
		if (InputPin && InputPin->LinkedTo.Num() > 0)
		{
			InputPin->PinType.PinCategory = InputPin->LinkedTo[0]->PinType.PinCategory;
			InputPin->PinType.PinSubCategory = InputPin->LinkedTo[0]->PinType.PinSubCategory;
			InputPin->PinType.PinSubCategoryObject = InputPin->LinkedTo[0]->PinType.PinSubCategoryObject;
		}
	}
	for (int32 i = 0; i < OutputPinNums; ++i)
	{
		UEdGraphPin* OutputPin = GetOutputPin(i);
		if (OutputPin && OutputPin->LinkedTo.Num() > 0)
		{
			OutputPin->PinType.PinCategory = OutputPin->LinkedTo[0]->PinType.PinCategory;
			OutputPin->PinType.PinSubCategory = OutputPin->LinkedTo[0]->PinType.PinSubCategory;
			OutputPin->PinType.PinSubCategoryObject = OutputPin->LinkedTo[0]->PinType.PinSubCategoryObject;
		}
	}

	Super::PostReconstructNode();
}


void UK2Node_BpCallLua::ExpandNode(class FKismetCompilerContext& CompilerContext, UEdGraph* SourceGraph)
{
	Super::ExpandNode(CompilerContext, SourceGraph);

	
	const UEdGraphSchema_K2* Schema = CompilerContext.GetSchema();

	UFunction* LuaCallFunction = ULuaBlueprintBridge::StaticClass()->FindFunctionByName(
		GET_FUNCTION_NAME_CHECKED(ULuaBlueprintBridge, LuaCallFunction));

	UK2Node_CallFunction* LuaCallFunctionNode = CompilerContext.SpawnIntermediateNode<UK2Node_CallFunction>(
		this, SourceGraph);

	LuaCallFunctionNode->SetFromFunction(LuaCallFunction);
	LuaCallFunctionNode->AllocateDefaultPins();

	// world context pin

	UEdGraphPin * WorldContextPin = FindPinChecked(FGetPinName::GetObjPin());
	if(WorldContextPin->LinkedTo.Num() > 0)
	{
		CompilerContext.
			MovePinLinksToIntermediate(*WorldContextPin, *LuaCallFunctionNode->FindPinChecked(TEXT("WorldContextObject")));
	}
	else
	{
		UK2Node_Self* SelfNode = CompilerContext.SpawnIntermediateNode<UK2Node_Self>(this, SourceGraph);
		SelfNode->AllocateDefaultPins();

		Schema->TryCreateConnection(SelfNode->FindPinChecked(UEdGraphSchema_K2::PN_Self), 
			LuaCallFunctionNode->FindPinChecked(TEXT("WorldContextObject")));
	}

	// funcname pin
	UEdGraphPin* FuncNamePin = FindPinChecked(FGetPinName::GetFuncPin());

	if (FuncNamePin->LinkedTo.Num() > 0)
	{
		CompilerContext.
			MovePinLinksToIntermediate(*FuncNamePin, *LuaCallFunctionNode->FindPinChecked(TEXT("funcname")));
	}
	else
	{
		CompilerContext.GetSchema()->TrySetDefaultValue(*LuaCallFunctionNode->FindPinChecked(TEXT("funcname")),
		                                                FuncNamePin->GetDefaultAsString());
	}

	TArray<UK2Node_CallFunction*> AllMakeVarFuncNodes;
	// var
	for(int32 i = 0; i < InputPinNums; ++i)
	{
		UEdGraphPin * VarPin = GetInputPin(i);
		if(VarPin && VarPin->LinkedTo.Num() == 1)
		{
			UEdGraphPin * InputVarPin = VarPin->LinkedTo[0];
			if(!InputVarPin)
			{
				continue;
			}
			if(InputVarPin->PinType.IsContainer())
			{
				// array map set ?
			}
			else
			{
				UFunction * MakeVarFunc = nullptr;
				if(InputVarPin->PinType.PinCategory == UEdGraphSchema_K2::PC_Boolean)
				{
					MakeVarFunc = ULuaBlueprintLibrary::StaticClass()->FindFunctionByName(
						GET_FUNCTION_NAME_CHECKED(ULuaBlueprintLibrary, CreateVarFromBool));
				}
				else if(InputVarPin->PinType.PinCategory == UEdGraphSchema_K2::PC_Int || InputVarPin->PinType.PinCategory == UEdGraphSchema_K2::PC_Int64)
				{
					MakeVarFunc = ULuaBlueprintLibrary::StaticClass()->FindFunctionByName(
						GET_FUNCTION_NAME_CHECKED(ULuaBlueprintLibrary, CreateVarFromInt));
				}
				else if(InputVarPin->PinType.PinCategory == UEdGraphSchema_K2::PC_Float)
				{
					MakeVarFunc = ULuaBlueprintLibrary::StaticClass()->FindFunctionByName(
						GET_FUNCTION_NAME_CHECKED(ULuaBlueprintLibrary, CreateVarFromNumber));
				}
				else if(InputVarPin->PinType.PinCategory == UEdGraphSchema_K2::PC_String)
				{
					MakeVarFunc = ULuaBlueprintLibrary::StaticClass()->FindFunctionByName(
						GET_FUNCTION_NAME_CHECKED(ULuaBlueprintLibrary, CreateVarFromString));
				}

				if(MakeVarFunc)
				{
					UK2Node_CallFunction* MakeVarFuncNode = CompilerContext.SpawnIntermediateNode<UK2Node_CallFunction>(
						this, SourceGraph);

					MakeVarFuncNode->SetFromFunction(MakeVarFunc);
					MakeVarFuncNode->AllocateDefaultPins();

					CompilerContext.
						MovePinLinksToIntermediate(*VarPin, *MakeVarFuncNode->FindPinChecked(TEXT("Value")));

					AllMakeVarFuncNodes.Add(MakeVarFuncNode);
				}
				else if(InputVarPin->PinType.PinCategory == UEdGraphSchema_K2::PC_Object)
				{
					// object
					MakeVarFunc = ULuaBlueprintBridge::StaticClass()->FindFunctionByName(
						GET_FUNCTION_NAME_CHECKED(ULuaBlueprintBridge, CreateVarFromObject));

					UK2Node_CallFunction* MakeVarFuncNode = CompilerContext.SpawnIntermediateNode<UK2Node_CallFunction>(
						this, SourceGraph);

					MakeVarFuncNode->SetFromFunction(MakeVarFunc);
					MakeVarFuncNode->AllocateDefaultPins();

					// UObject* WorldContextObject, UObject* InTheObject

					if (WorldContextPin->LinkedTo.Num() > 0)
					{
						Schema->TryCreateConnection(WorldContextPin->LinkedTo[0], MakeVarFuncNode->FindPinChecked(TEXT("WorldContextObject")));
					}
					else
					{
						UK2Node_Self* SelfNode = CompilerContext.SpawnIntermediateNode<UK2Node_Self>(this, SourceGraph);
						SelfNode->AllocateDefaultPins();

						Schema->TryCreateConnection(SelfNode->FindPinChecked(UEdGraphSchema_K2::PN_Self),
							MakeVarFuncNode->FindPinChecked(TEXT("WorldContextObject")));
					}

					CompilerContext.
						MovePinLinksToIntermediate(*VarPin, *MakeVarFuncNode->FindPinChecked(TEXT("InTheObject")));

					AllMakeVarFuncNodes.Add(MakeVarFuncNode);
				}
			}

		}
		else
		{
		}
	}

	UK2Node_MakeArray* MakeArrayNode = CompilerContext.SpawnIntermediateNode<UK2Node_MakeArray>(this, SourceGraph);
	MakeArrayNode->AllocateDefaultPins();

	if (MakeArrayNode->GetOutputPin())
	{
		MakeArrayNode->GetOutputPin()->MakeLinkTo(LuaCallFunctionNode->FindPinChecked(TEXT("args")));

		MakeArrayNode->PinConnectionListChanged(MakeArrayNode->GetOutputPin());
	}


	for(int32 i = 0; i < AllMakeVarFuncNodes.Num(); ++i)
	{
		// The "Make Array" node already has one pin available, so don't create one for ArgIdx == 0
		if(i > 0)
		{
			MakeArrayNode->AddInputPin();
		}
		const FString PinName = FString::Printf(TEXT("[%d]"), i);
		UEdGraphPin* MakeArrayPinAtIndex = MakeArrayNode->FindPinChecked(PinName);

		UK2Node_CallFunction * MakeVarFuncNode = AllMakeVarFuncNodes[i];
		UEdGraphPin * ResultPin = MakeVarFuncNode->GetReturnValuePin();
		if(ResultPin)
		{
			ResultPin->MakeLinkTo(MakeArrayPinAtIndex);
		}
	}
	


	UEdGraphPin* ThisInputPin = FindPinChecked(UEdGraphSchema_K2::PN_Execute);
	UEdGraphPin* ThisOutputPin = FindPinChecked(UEdGraphSchema_K2::PN_Then);

	CompilerContext.MovePinLinksToIntermediate(*ThisInputPin,
		*LuaCallFunctionNode->FindPinChecked(UEdGraphSchema_K2::PN_Execute));

	CompilerContext.MovePinLinksToIntermediate(*ThisOutputPin,
		*LuaCallFunctionNode->FindPinChecked(UEdGraphSchema_K2::PN_Then));

	BreakAllNodeLinks();
}


//This method adds our node to the context menu
void UK2Node_BpCallLua::GetMenuActions(FBlueprintActionDatabaseRegistrar& ActionRegistrar) const
{
	Super::GetMenuActions(ActionRegistrar);

	UClass* Action = GetClass();

	if (ActionRegistrar.IsOpenForRegistration(Action))
	{
		UBlueprintNodeSpawner* Spawner = UBlueprintNodeSpawner::Create(GetClass());
		check(Spawner != nullptr);

		ActionRegistrar.AddBlueprintAction(Action, Spawner);
	}
}


void UK2Node_BpCallLua::AddInputPin()
{
	AddInputPinsInner(InputPinNums);
	InputPinNums += 1;
	GetGraph()->NotifyGraphChanged();
}

void UK2Node_BpCallLua::AddOutputPin()
{
	FString PinName = FString::Printf(TEXT("LuaOutput%d"), OutputPinNums);
	CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Wildcard, FName(*PinName));
	OutputPinNums += 1;
	GetGraph()->NotifyGraphChanged();
}

UEdGraphPin* UK2Node_BpCallLua::GetOutputPin(int32 PinIndex)
{
	FString PinName = FString::Printf(TEXT("Output%d"), OutputPinNums);
	UEdGraphPin* OutputPin = FindPinChecked(PinName);
	return OutputPin;
}

void UK2Node_BpCallLua::NotifyPinConnectionListChanged(UEdGraphPin* Pin)
{
	Super::NotifyPinConnectionListChanged(Pin);

	if (Pin && Pin->LinkedTo.Num() > 0)
	{
		Pin->PinType = Pin->LinkedTo[0]->PinType;
	}
	else if (Pin)
	{
		Pin->PinType.PinCategory = UEdGraphSchema_K2::PC_Wildcard;
	}

	GetGraph()->NotifyGraphChanged();
}

void UK2Node_BpCallLua::AddInputPinsInner(int32 PinIndex)
{
	FString PinName = FGetPinName::GetVariableInputPin(PinIndex);

	CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Wildcard, FName(*PinName));
}

UEdGraphPin* UK2Node_BpCallLua::GetInputPin(int32 PinIndex)
{
	FString PinName = FGetPinName::GetVariableInputPin(PinIndex);
	UEdGraphPin* InputPin = FindPinChecked(PinName);
	return InputPin;
}


#undef LOCTEXT_NAMESPACE
